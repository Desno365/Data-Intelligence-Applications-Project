import numpy as np

# this is too big to calculate for depth more than 5
# def binary_strings(depth):
#   if depth < 1:
#     print('no')
#     return
#   if depth == 1:
#     return ['0', '1']
#   result = []
#   for i in binary_strings(depth-1):
#     result.append('0' + i)
#     result.append('1' + i)
#   result.sort()
#   return result


# measure exact activations by complete enumeration
# input: seeds (the nodes that start the influence cascade)
# output: average (average number of nodes activated by seeds in each simulation);
# output: ground_truth_activation_probabilities (activation probability of each node)
def calculateActivations(seeds):
    # enumerate all live edge graphs to calculate node activation probability
    # takes 1 minute to compute with a fully connected graph (with no self loops) with 5 nodes
    # print(2 ** (Network.n * (Network.n - 1))) #number of live edge graphs to enumerate
    # reset previously calculated values
    for a in Network.nodes:
        a.activation_probability = 0

    progress_index = 1  # track loop progress for very long computations
    average = 0  # number of nodes activated by seed on average

    # loop over all possible live edge graphs
    for live_edge_graph_index in range(2 ** (Network.n * (Network.n - 1))):
        #####################################################################################################
        live_edges = []  # which edges are active in the live edge graph
        # there are at most n*(n-1) edges (no self loops)
        for a in range(Network.n * (Network.n - 1)):
            live_edges.append('0')
        binary_string = "{0:b}".format(live_edge_graph_index)  # binary string of live_edge_graph_index
        live_edges[-len(binary_string):] = list(binary_string)
        #####################################################################################################
        live = np.zeros((Network.n, Network.n))  # adjacency matrix for the live edge graph
        edge_index = -1
        # create live edge graph corresponding to the current live_edge_graph_index
        for j in range(Network.n):
            for jj in range(Network.n):
                if Network.adjacency_matrix[j][jj] == 1:
                    edge_index += 1
                    if live_edges[edge_index] == '1':
                        live[j][jj] = Network.adjacency_matrix[j][jj]
        #####################################################################################################
        # calculate the probability of the current live edge graph
        probability = 0
        for i in range(Network.n):
            for ii in range(Network.n):
                if live[i][ii] == '1':
                    if probability == 0:
                        probability = Network.weight_matrix[Network.nodes[i].category][Network.nodes[ii].category]
                    else:
                        probability = probability * Network.weight_matrix[Network.nodes[i].category][Network.nodes[ii].category]
                elif live[i][ii] == '0':
                    if probability == 0:
                        probability = 1 - Network.weight_matrix[Network.nodes[i].category][Network.nodes[ii].category]
                    else:
                        probability = probability * (1 - Network.weight_matrix[Network.nodes[i].category][
                            Network.nodes[ii].category])
                else:
                    print('big no no')
        #####################################################################################################
        active_nodes = Network.calculate_activated_nodes(seeds, live)
        average += len(active_nodes)

        for node_index in active_nodes:
            # this is only true for weights = 0.5
            # Network.nodes[node_index].activation_probability += 1 / (2 ** (Network.n * (Network.n - 1)))
            Network.nodes[node_index].activation_probability += probability
        #####################################################################################################
        progress_index += 1
        if progress_index % 100000 == 0:
            print(progress_index)
    #####################################################################################################
    average = average / (2 ** (Network.n * (Network.n - 1)))
    ground_truth_activation_probabilities = []
    for a in Network.nodes:
        ground_truth_activation_probabilities.append(a.activation_probability)
        # print(a.activation_probability)
    # print('average number of activated nodes: ', average)
    return average, ground_truth_activation_probabilities


# calculate the influence generated by the seeds using approximated monte carlo method
# input: seeds (the nodes that start the influence cascade)
# input: iterations (how many iterations of the simulation to do)
# [more iterations takes more time and gives more accurate results]
# output: average_active_nodes (average number of active nodes in all the simulations)
# output: estimated_activation_probabilities (estimated activation probability for each node in the network)
def monteCarloEstimation(seeds = [0], iterations = 100):
    # monte carlo sampling
    # reset previously calculated values
    average_active_nodes = 0
    for i in Network.nodes:
        i.z = 0
        i.activation_probability = 0

    for i in range(iterations):
        # generate live edge graph and calculate activated nodes
        live, p = Network.generate_live_edge_graph()
        active_nodes = Network.calculate_activated_nodes(seeds, live)
        active_nodes.sort()
        # update average number of activated nodes
        if i == 0:
            average_active_nodes = len(active_nodes)
        else:
            average_active_nodes = (average_active_nodes * (i) + len(active_nodes)) / (i + 1)
        # update node activation counts
        for nod in active_nodes:
            Network.nodes[nod].z += 1
        # progress print for very long calculations
        if i % 100000 == 0:
            print('progress: ', i)
    estimated_activation_probabilities = []
    for i in range(Network.n):
        ap = Network.nodes[i].z / iterations
        Network.nodes[i].activation_probability = ap
        estimated_activation_probabilities.append(ap)

    return average_active_nodes, estimated_activation_probabilities


# calculate the error of the estimated probabilities wrt the ground truth if available
# input: ground truth
# input: estimations
# output: sum of squares error on activation probabilities
def evaluateError(ground_truth_activation_probabilities, estimated_activation_probabilities):
    error = 0
    for asd in range(len(Network.nodes)):
        error += (ground_truth_activation_probabilities[asd] - estimated_activation_probabilities[asd]) ** 2
